// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "server.hpp"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace openstack
{
  namespace xml
  {
    // Server_
    // 

    const ::xml_schema::Type* Server_::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Server_::
    _value ()
    {
      return &this->value_.get ();
    }

    Server_::
    Server_ (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Server_::
    Server_ (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Server_::
    Server_ (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Server_::
    Server_ (const Server_& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Server_* Server_::
    _clone (::xml_schema::Flags f) const
    {
      return new class Server_ (*this, f);
    }

    const ::std::string& Server_::
    name ()
    {
      return name_;
    }

    const ::std::string& Server_::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Server_::
    _name () const
    {
      return name_;
    }

    const ::std::string& Server_::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Server_::
    name_ ("server");

    const ::std::string Server_::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Server_::
    ~Server_ ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Server_, char, ::xml_schema::Type >
    _xsd_Server__parser_init (Server_::name (), Server_::namespace_ ());

    // Servers_
    // 

    const ::xml_schema::Type* Servers_::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Servers_::
    _value ()
    {
      return &this->value_.get ();
    }

    Servers_::
    Servers_ (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Servers_::
    Servers_ (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Servers_::
    Servers_ (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Servers_::
    Servers_ (const Servers_& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Servers_* Servers_::
    _clone (::xml_schema::Flags f) const
    {
      return new class Servers_ (*this, f);
    }

    const ::std::string& Servers_::
    name ()
    {
      return name_;
    }

    const ::std::string& Servers_::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Servers_::
    _name () const
    {
      return name_;
    }

    const ::std::string& Servers_::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Servers_::
    name_ ("servers");

    const ::std::string Servers_::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Servers_::
    ~Servers_ ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Servers_, char, ::xml_schema::Type >
    _xsd_Servers__parser_init (Servers_::name (), Servers_::namespace_ ());

    // Addresses_
    // 

    const ::xml_schema::Type* Addresses_::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Addresses_::
    _value ()
    {
      return &this->value_.get ();
    }

    Addresses_::
    Addresses_ (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Addresses_::
    Addresses_ (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Addresses_::
    Addresses_ (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Addresses_::
    Addresses_ (const Addresses_& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Addresses_* Addresses_::
    _clone (::xml_schema::Flags f) const
    {
      return new class Addresses_ (*this, f);
    }

    const ::std::string& Addresses_::
    name ()
    {
      return name_;
    }

    const ::std::string& Addresses_::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Addresses_::
    _name () const
    {
      return name_;
    }

    const ::std::string& Addresses_::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Addresses_::
    name_ ("addresses");

    const ::std::string Addresses_::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Addresses_::
    ~Addresses_ ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Addresses_, char, ::xml_schema::Type >
    _xsd_Addresses__parser_init (Addresses_::name (), Addresses_::namespace_ ());

    // Public
    // 

    const ::xml_schema::Type* Public::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Public::
    _value ()
    {
      return &this->value_.get ();
    }

    Public::
    Public (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Public::
    Public (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Public::
    Public (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Public::
    Public (const Public& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Public* Public::
    _clone (::xml_schema::Flags f) const
    {
      return new class Public (*this, f);
    }

    const ::std::string& Public::
    name ()
    {
      return name_;
    }

    const ::std::string& Public::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Public::
    _name () const
    {
      return name_;
    }

    const ::std::string& Public::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Public::
    name_ ("public");

    const ::std::string Public::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Public::
    ~Public ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Public, char, ::xml_schema::Type >
    _xsd_Public_parser_init (Public::name (), Public::namespace_ ());

    // Private
    // 

    const ::xml_schema::Type* Private::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Private::
    _value ()
    {
      return &this->value_.get ();
    }

    Private::
    Private (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Private::
    Private (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Private::
    Private (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Private::
    Private (const Private& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Private* Private::
    _clone (::xml_schema::Flags f) const
    {
      return new class Private (*this, f);
    }

    const ::std::string& Private::
    name ()
    {
      return name_;
    }

    const ::std::string& Private::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Private::
    _name () const
    {
      return name_;
    }

    const ::std::string& Private::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Private::
    name_ ("private");

    const ::std::string Private::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Private::
    ~Private ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Private, char, ::xml_schema::Type >
    _xsd_Private_parser_init (Private::name (), Private::namespace_ ());

    // ShareIp_
    // 

    const ::xml_schema::Type* ShareIp_::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* ShareIp_::
    _value ()
    {
      return &this->value_.get ();
    }

    ShareIp_::
    ShareIp_ (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    ShareIp_::
    ShareIp_ (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    ShareIp_::
    ShareIp_ (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ShareIp_::
    ShareIp_ (const ShareIp_& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    ShareIp_* ShareIp_::
    _clone (::xml_schema::Flags f) const
    {
      return new class ShareIp_ (*this, f);
    }

    const ::std::string& ShareIp_::
    name ()
    {
      return name_;
    }

    const ::std::string& ShareIp_::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ShareIp_::
    _name () const
    {
      return name_;
    }

    const ::std::string& ShareIp_::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ShareIp_::
    name_ ("shareIp");

    const ::std::string ShareIp_::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    ShareIp_::
    ~ShareIp_ ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ShareIp_, char, ::xml_schema::Type >
    _xsd_ShareIp__parser_init (ShareIp_::name (), ShareIp_::namespace_ ());

    // Server
    //

    Server::
    Server ()
    : ::xml_schema::Type (),
      metadata_ (::xml_schema::Flags (), this),
      addresses_ (::xml_schema::Flags (), this),
      personality_ (::xml_schema::Flags (), this),
      name_ (::xml_schema::Flags (), this),
      id_ (::xml_schema::Flags (), this),
      adminPass_ (::xml_schema::Flags (), this),
      imageId_ (::xml_schema::Flags (), this),
      flavorId_ (::xml_schema::Flags (), this),
      hostId_ (::xml_schema::Flags (), this),
      progress_ (::xml_schema::Flags (), this),
      status_ (::xml_schema::Flags (), this),
      sharedIpGroupId_ (::xml_schema::Flags (), this)
    {
    }

    Server::
    Server (const Server& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      metadata_ (x.metadata_, f, this),
      addresses_ (x.addresses_, f, this),
      personality_ (x.personality_, f, this),
      name_ (x.name_, f, this),
      id_ (x.id_, f, this),
      adminPass_ (x.adminPass_, f, this),
      imageId_ (x.imageId_, f, this),
      flavorId_ (x.flavorId_, f, this),
      hostId_ (x.hostId_, f, this),
      progress_ (x.progress_, f, this),
      status_ (x.status_, f, this),
      sharedIpGroupId_ (x.sharedIpGroupId_, f, this)
    {
    }

    Server::
    Server (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      metadata_ (f, this),
      addresses_ (f, this),
      personality_ (f, this),
      name_ (f, this),
      id_ (f, this),
      adminPass_ (f, this),
      imageId_ (f, this),
      flavorId_ (f, this),
      hostId_ (f, this),
      progress_ (f, this),
      status_ (f, this),
      sharedIpGroupId_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Server::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // metadata
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "metadata",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< MetadataType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->metadata_)
            {
              ::std::auto_ptr< MetadataType > r (
                dynamic_cast< MetadataType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->metadata_.set (r);
              continue;
            }
          }
        }

        // addresses
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "addresses",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< AddressesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->addresses_)
            {
              ::std::auto_ptr< AddressesType > r (
                dynamic_cast< AddressesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->addresses_.set (r);
              continue;
            }
          }
        }

        // personality
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "personality",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< PersonalityType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->personality_)
            {
              ::std::auto_ptr< PersonalityType > r (
                dynamic_cast< PersonalityType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->personality_.set (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameType > r (
            NameTraits::create (i, f, this));

          this->name_.set (r);
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "adminPass" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AdminPassType > r (
            AdminPassTraits::create (i, f, this));

          this->adminPass_.set (r);
          continue;
        }

        if (n.name () == "imageId" && n.namespace_ ().empty ())
        {
          this->imageId_.set (ImageIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "flavorId" && n.namespace_ ().empty ())
        {
          this->flavorId_.set (FlavorIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "hostId" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< HostIdType > r (
            HostIdTraits::create (i, f, this));

          this->hostId_.set (r);
          continue;
        }

        if (n.name () == "progress" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ProgressType > r (
            ProgressTraits::create (i, f, this));

          this->progress_.set (r);
          continue;
        }

        if (n.name () == "status" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< StatusType > r (
            StatusTraits::create (i, f, this));

          this->status_.set (r);
          continue;
        }

        if (n.name () == "sharedIpGroupId" && n.namespace_ ().empty ())
        {
          this->sharedIpGroupId_.set (SharedIpGroupIdTraits::create (i, f, this));
          continue;
        }
      }
    }

    Server* Server::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Server (*this, f, c);
    }

    Server::
    ~Server ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Server >
    _xsd_Server_type_factory_init (
      "Server",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // Servers
    //

    Servers::
    Servers ()
    : ::xml_schema::Type (),
      server_ (::xml_schema::Flags (), this)
    {
    }

    Servers::
    Servers (const Servers& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      server_ (x.server_, f, this)
    {
    }

    Servers::
    Servers (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      server_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Servers::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // server
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "server",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< ServerType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ServerType > r (
              dynamic_cast< ServerType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->server_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    Servers* Servers::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Servers (*this, f, c);
    }

    Servers::
    ~Servers ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Servers >
    _xsd_Servers_type_factory_init (
      "Servers",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // Metadata
    //

    Metadata::
    Metadata ()
    : ::xml_schema::Type (),
      meta_ (::xml_schema::Flags (), this)
    {
    }

    Metadata::
    Metadata (const Metadata& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      meta_ (x.meta_, f, this)
    {
    }

    Metadata::
    Metadata (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      meta_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Metadata::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // meta
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "meta",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< MetaType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< MetaType > r (
              dynamic_cast< MetaType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->meta_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    Metadata* Metadata::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Metadata (*this, f, c);
    }

    Metadata::
    ~Metadata ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Metadata >
    _xsd_Metadata_type_factory_init (
      "Metadata",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // MetadataValue
    //

    MetadataValue::
    MetadataValue ()
    : ::xml_schema::String ()
    {
    }

    MetadataValue::
    MetadataValue (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataValue::
    MetadataValue (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataValue::
    MetadataValue (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataValue::
    MetadataValue (const MetadataValue& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    MetadataValue::
    MetadataValue (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    MetadataValue::
    MetadataValue (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    MetadataValue::
    MetadataValue (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    MetadataValue* MetadataValue::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MetadataValue (*this, f, c);
    }

    MetadataValue::
    ~MetadataValue ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetadataValue >
    _xsd_MetadataValue_type_factory_init (
      "MetadataValue",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // MetadataItem
    //

    MetadataItem::
    MetadataItem (const KeyType& key)
    : ::openstack::xml::MetadataValue (),
      key_ (key, ::xml_schema::Flags (), this)
    {
    }

    MetadataItem::
    MetadataItem (const char* _xsd_String_base,
                  const KeyType& key)
    : ::openstack::xml::MetadataValue (_xsd_String_base),
      key_ (key, ::xml_schema::Flags (), this)
    {
    }

    MetadataItem::
    MetadataItem (const ::std::string& _xsd_String_base,
                  const KeyType& key)
    : ::openstack::xml::MetadataValue (_xsd_String_base),
      key_ (key, ::xml_schema::Flags (), this)
    {
    }

    MetadataItem::
    MetadataItem (const ::xml_schema::String& _xsd_String_base,
                  const KeyType& key)
    : ::openstack::xml::MetadataValue (_xsd_String_base),
      key_ (key, ::xml_schema::Flags (), this)
    {
    }

    MetadataItem::
    MetadataItem (const MetadataItem& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::openstack::xml::MetadataValue (x, f, c),
      key_ (x.key_, f, this)
    {
    }

    MetadataItem::
    MetadataItem (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::openstack::xml::MetadataValue (e, f | ::xml_schema::Flags::base, c),
      key_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void MetadataItem::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          this->key_.set (r);
          continue;
        }
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }
    }

    MetadataItem* MetadataItem::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MetadataItem (*this, f, c);
    }

    MetadataItem::
    ~MetadataItem ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetadataItem >
    _xsd_MetadataItem_type_factory_init (
      "MetadataItem",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // Personality
    //

    Personality::
    Personality ()
    : ::xml_schema::Type (),
      file_ (::xml_schema::Flags (), this)
    {
    }

    Personality::
    Personality (const Personality& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      file_ (x.file_, f, this)
    {
    }

    Personality::
    Personality (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      file_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Personality::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // file
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "file",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< FileType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FileType > r (
              dynamic_cast< FileType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->file_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    Personality* Personality::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Personality (*this, f, c);
    }

    Personality::
    ~Personality ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Personality >
    _xsd_Personality_type_factory_init (
      "Personality",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // FileContent
    //

    FileContent::
    FileContent ()
    : ::xml_schema::Base64Binary ()
    {
    }

    FileContent::
    FileContent (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
    : ::xml_schema::Base64Binary (_xsd_Base64Binary_base)
    {
    }

    FileContent::
    FileContent (const FileContent& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (x, f, c)
    {
    }

    FileContent::
    FileContent (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (e, f, c)
    {
    }

    FileContent::
    FileContent (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (a, f, c)
    {
    }

    FileContent::
    FileContent (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Base64Binary (s, e, f, c)
    {
    }

    FileContent* FileContent::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FileContent (*this, f, c);
    }

    FileContent::
    ~FileContent ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FileContent >
    _xsd_FileContent_type_factory_init (
      "FileContent",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // File
    //

    File::
    File (const PathType& path)
    : ::openstack::xml::FileContent (),
      path_ (path, ::xml_schema::Flags (), this)
    {
    }

    File::
    File (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base,
          const PathType& path)
    : ::openstack::xml::FileContent (_xsd_Base64Binary_base),
      path_ (path, ::xml_schema::Flags (), this)
    {
    }

    File::
    File (const File& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::openstack::xml::FileContent (x, f, c),
      path_ (x.path_, f, this)
    {
    }

    File::
    File (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::openstack::xml::FileContent (e, f | ::xml_schema::Flags::base, c),
      path_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void File::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "path" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PathType > r (
            PathTraits::create (i, f, this));

          this->path_.set (r);
          continue;
        }
      }

      if (!path_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "path",
          "");
      }
    }

    File* File::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class File (*this, f, c);
    }

    File::
    ~File ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, File >
    _xsd_File_type_factory_init (
      "File",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // Addresses
    //

    Addresses::
    Addresses ()
    : ::xml_schema::Type (),
      public__ (::xml_schema::Flags (), this),
      private__ (::xml_schema::Flags (), this)
    {
    }

    Addresses::
    Addresses (const Addresses& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      public__ (x.public__, f, this),
      private__ (x.private__, f, this)
    {
    }

    Addresses::
    Addresses (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      public__ (f, this),
      private__ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Addresses::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // public
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "public",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< PublicType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->public__)
            {
              ::std::auto_ptr< PublicType > r (
                dynamic_cast< PublicType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->public__.set (r);
              continue;
            }
          }
        }

        // private
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "private",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< PrivateType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->private__)
            {
              ::std::auto_ptr< PrivateType > r (
                dynamic_cast< PrivateType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->private__.set (r);
              continue;
            }
          }
        }

        break;
      }
    }

    Addresses* Addresses::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Addresses (*this, f, c);
    }

    Addresses::
    ~Addresses ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Addresses >
    _xsd_Addresses_type_factory_init (
      "Addresses",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // AddressList
    //

    AddressList::
    AddressList ()
    : ::xml_schema::Type (),
      ip_ (::xml_schema::Flags (), this)
    {
    }

    AddressList::
    AddressList (const AddressList& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ip_ (x.ip_, f, this)
    {
    }

    AddressList::
    AddressList (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ip_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void AddressList::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ip
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "ip",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< IpType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< IpType > r (
              dynamic_cast< IpType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ip_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AddressList* AddressList::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AddressList (*this, f, c);
    }

    AddressList::
    ~AddressList ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AddressList >
    _xsd_AddressList_type_factory_init (
      "AddressList",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // Address
    //

    Address::
    Address (const AddrType& addr)
    : ::xml_schema::Type (),
      addr_ (addr, ::xml_schema::Flags (), this)
    {
    }

    Address::
    Address (const Address& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      addr_ (x.addr_, f, this)
    {
    }

    Address::
    Address (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      addr_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void Address::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "addr" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AddrType > r (
            AddrTraits::create (i, f, this));

          this->addr_.set (r);
          continue;
        }
      }

      if (!addr_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "addr",
          "");
      }
    }

    Address* Address::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Address (*this, f, c);
    }

    Address::
    ~Address ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Address >
    _xsd_Address_type_factory_init (
      "Address",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ShareIp
    //

    ShareIp::
    ShareIp (const SharedIpGroupIdType& sharedIpGroupId)
    : ::xml_schema::Type (),
      sharedIpGroupId_ (sharedIpGroupId, ::xml_schema::Flags (), this),
      configureServer_ (configureServerDefaultValue (), ::xml_schema::Flags (), this)
    {
    }

    ShareIp::
    ShareIp (const ShareIp& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      sharedIpGroupId_ (x.sharedIpGroupId_, f, this),
      configureServer_ (x.configureServer_, f, this)
    {
    }

    ShareIp::
    ShareIp (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      sharedIpGroupId_ (f, this),
      configureServer_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ShareIp::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "sharedIpGroupId" && n.namespace_ ().empty ())
        {
          this->sharedIpGroupId_.set (SharedIpGroupIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "configureServer" && n.namespace_ ().empty ())
        {
          this->configureServer_.set (ConfigureServerTraits::create (i, f, this));
          continue;
        }
      }

      if (!sharedIpGroupId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "sharedIpGroupId",
          "");
      }

      if (!configureServer_.present ())
      {
        this->configureServer_.set (configureServerDefaultValue ());
      }
    }

    ShareIp* ShareIp::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ShareIp (*this, f, c);
    }

    ShareIp::
    ~ShareIp ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ShareIp >
    _xsd_ShareIp_type_factory_init (
      "ShareIp",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ServerStatus
    //

    ServerStatus::
    ServerStatus (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_ServerStatus_convert ();
    }

    ServerStatus::
    ServerStatus (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_ServerStatus_convert ();
    }

    ServerStatus::
    ServerStatus (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_ServerStatus_convert ();
    }

    ServerStatus* ServerStatus::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ServerStatus (*this, f, c);
    }

    ServerStatus::Value ServerStatus::
    _xsd_ServerStatus_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ServerStatus_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_ServerStatus_indexes_,
                        _xsd_ServerStatus_indexes_ + 24,
                        *this,
                        c));

      if (i == _xsd_ServerStatus_indexes_ + 24 || _xsd_ServerStatus_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ServerStatus::
    _xsd_ServerStatus_literals_[24] =
    {
      "ACTIVE",
      "SUSPENDED",
      "DELETED",
      "QUEUE_RESIZE",
      "PREP_RESIZE",
      "RESIZE",
      "VERIFY_RESIZE",
      "RESCUE",
      "ERROR",
      "BUILD",
      "RESTORING",
      "PASSWORD",
      "REBUILD",
      "DELETE_IP",
      "SHARE_IP_NO_CONFIG",
      "SHARE_IP",
      "REBOOT",
      "HARD_REBOOT",
      "UNKNOWN",
      "QUEUE_MOVE",
      "PREP_MOVE",
      "MOVE",
      "VERIFY_MOVE",
      "PENDING"
    };

    const ServerStatus::Value ServerStatus::
    _xsd_ServerStatus_indexes_[24] =
    {
      ::openstack::xml::ServerStatus::ACTIVE,
      ::openstack::xml::ServerStatus::BUILD,
      ::openstack::xml::ServerStatus::DELETED,
      ::openstack::xml::ServerStatus::DELETE_IP,
      ::openstack::xml::ServerStatus::ERROR,
      ::openstack::xml::ServerStatus::HARD_REBOOT,
      ::openstack::xml::ServerStatus::MOVE,
      ::openstack::xml::ServerStatus::PASSWORD,
      ::openstack::xml::ServerStatus::PENDING,
      ::openstack::xml::ServerStatus::PREP_MOVE,
      ::openstack::xml::ServerStatus::PREP_RESIZE,
      ::openstack::xml::ServerStatus::QUEUE_MOVE,
      ::openstack::xml::ServerStatus::QUEUE_RESIZE,
      ::openstack::xml::ServerStatus::REBOOT,
      ::openstack::xml::ServerStatus::REBUILD,
      ::openstack::xml::ServerStatus::RESCUE,
      ::openstack::xml::ServerStatus::RESIZE,
      ::openstack::xml::ServerStatus::RESTORING,
      ::openstack::xml::ServerStatus::SHARE_IP,
      ::openstack::xml::ServerStatus::SHARE_IP_NO_CONFIG,
      ::openstack::xml::ServerStatus::SUSPENDED,
      ::openstack::xml::ServerStatus::UNKNOWN,
      ::openstack::xml::ServerStatus::VERIFY_MOVE,
      ::openstack::xml::ServerStatus::VERIFY_RESIZE
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ServerStatus >
    _xsd_ServerStatus_type_factory_init (
      "ServerStatus",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // FileName
    //

    FileName::
    FileName ()
    : ::xml_schema::String ()
    {
    }

    FileName::
    FileName (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const FileName& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    FileName::
    FileName (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    FileName::
    FileName (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    FileName::
    FileName (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    FileName* FileName::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FileName (*this, f, c);
    }

    FileName::
    ~FileName ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FileName >
    _xsd_FileName_type_factory_init (
      "FileName",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // MetadataKey
    //

    MetadataKey::
    MetadataKey ()
    : ::xml_schema::String ()
    {
    }

    MetadataKey::
    MetadataKey (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataKey::
    MetadataKey (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataKey::
    MetadataKey (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetadataKey::
    MetadataKey (const MetadataKey& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    MetadataKey::
    MetadataKey (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    MetadataKey::
    MetadataKey (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    MetadataKey::
    MetadataKey (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    MetadataKey* MetadataKey::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MetadataKey (*this, f, c);
    }

    MetadataKey::
    ~MetadataKey ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetadataKey >
    _xsd_MetadataKey_type_factory_init (
      "MetadataKey",
      "http://docs.rackspacecloud.com/servers/api/v1.0");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

