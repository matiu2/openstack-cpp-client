// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "faults.hpp"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace openstack
{
  namespace xml
  {
    // CloudServersFault
    // 

    const ::xml_schema::Type* CloudServersFault::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* CloudServersFault::
    _value ()
    {
      return &this->value_.get ();
    }

    CloudServersFault::
    CloudServersFault (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    CloudServersFault::
    CloudServersFault (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    CloudServersFault::
    CloudServersFault (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    CloudServersFault::
    CloudServersFault (const CloudServersFault& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    CloudServersFault* CloudServersFault::
    _clone (::xml_schema::Flags f) const
    {
      return new class CloudServersFault (*this, f);
    }

    const ::std::string& CloudServersFault::
    name ()
    {
      return name_;
    }

    const ::std::string& CloudServersFault::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& CloudServersFault::
    _name () const
    {
      return name_;
    }

    const ::std::string& CloudServersFault::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string CloudServersFault::
    name_ ("cloudServersFault");

    const ::std::string CloudServersFault::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    CloudServersFault::
    ~CloudServersFault ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< CloudServersFault, char, ::xml_schema::Type >
    _xsd_CloudServersFault_parser_init (CloudServersFault::name (), CloudServersFault::namespace_ ());

    // ItemNotFound
    // 

    const ::xml_schema::Type* ItemNotFound::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* ItemNotFound::
    _value ()
    {
      return &this->value_.get ();
    }

    ItemNotFound::
    ItemNotFound (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    ItemNotFound::
    ItemNotFound (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    ItemNotFound::
    ItemNotFound (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ItemNotFound::
    ItemNotFound (const ItemNotFound& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    ItemNotFound* ItemNotFound::
    _clone (::xml_schema::Flags f) const
    {
      return new class ItemNotFound (*this, f);
    }

    const ::std::string& ItemNotFound::
    name ()
    {
      return name_;
    }

    const ::std::string& ItemNotFound::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ItemNotFound::
    _name () const
    {
      return name_;
    }

    const ::std::string& ItemNotFound::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ItemNotFound::
    name_ ("itemNotFound");

    const ::std::string ItemNotFound::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    ItemNotFound::
    ~ItemNotFound ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ItemNotFound, char, ::xml_schema::Type >
    _xsd_ItemNotFound_parser_init (ItemNotFound::name (), ItemNotFound::namespace_ ());

    // BuildInProgress
    // 

    const ::xml_schema::Type* BuildInProgress::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* BuildInProgress::
    _value ()
    {
      return &this->value_.get ();
    }

    BuildInProgress::
    BuildInProgress (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    BuildInProgress::
    BuildInProgress (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    BuildInProgress::
    BuildInProgress (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BuildInProgress::
    BuildInProgress (const BuildInProgress& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    BuildInProgress* BuildInProgress::
    _clone (::xml_schema::Flags f) const
    {
      return new class BuildInProgress (*this, f);
    }

    const ::std::string& BuildInProgress::
    name ()
    {
      return name_;
    }

    const ::std::string& BuildInProgress::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BuildInProgress::
    _name () const
    {
      return name_;
    }

    const ::std::string& BuildInProgress::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BuildInProgress::
    name_ ("buildInProgress");

    const ::std::string BuildInProgress::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    BuildInProgress::
    ~BuildInProgress ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BuildInProgress, char, ::xml_schema::Type >
    _xsd_BuildInProgress_parser_init (BuildInProgress::name (), BuildInProgress::namespace_ ());

    // ServerCapacityUnavailable
    // 

    const ::xml_schema::Type* ServerCapacityUnavailable::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* ServerCapacityUnavailable::
    _value ()
    {
      return &this->value_.get ();
    }

    ServerCapacityUnavailable::
    ServerCapacityUnavailable (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    ServerCapacityUnavailable::
    ServerCapacityUnavailable (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    ServerCapacityUnavailable::
    ServerCapacityUnavailable (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ServerCapacityUnavailable::
    ServerCapacityUnavailable (const ServerCapacityUnavailable& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    ServerCapacityUnavailable* ServerCapacityUnavailable::
    _clone (::xml_schema::Flags f) const
    {
      return new class ServerCapacityUnavailable (*this, f);
    }

    const ::std::string& ServerCapacityUnavailable::
    name ()
    {
      return name_;
    }

    const ::std::string& ServerCapacityUnavailable::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ServerCapacityUnavailable::
    _name () const
    {
      return name_;
    }

    const ::std::string& ServerCapacityUnavailable::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ServerCapacityUnavailable::
    name_ ("serverCapacityUnavailable");

    const ::std::string ServerCapacityUnavailable::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    ServerCapacityUnavailable::
    ~ServerCapacityUnavailable ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ServerCapacityUnavailable, char, ::xml_schema::Type >
    _xsd_ServerCapacityUnavailable_parser_init (ServerCapacityUnavailable::name (), ServerCapacityUnavailable::namespace_ ());

    // BackupOrResizeInProgress
    // 

    const ::xml_schema::Type* BackupOrResizeInProgress::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* BackupOrResizeInProgress::
    _value ()
    {
      return &this->value_.get ();
    }

    BackupOrResizeInProgress::
    BackupOrResizeInProgress (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    BackupOrResizeInProgress::
    BackupOrResizeInProgress (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    BackupOrResizeInProgress::
    BackupOrResizeInProgress (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BackupOrResizeInProgress::
    BackupOrResizeInProgress (const BackupOrResizeInProgress& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    BackupOrResizeInProgress* BackupOrResizeInProgress::
    _clone (::xml_schema::Flags f) const
    {
      return new class BackupOrResizeInProgress (*this, f);
    }

    const ::std::string& BackupOrResizeInProgress::
    name ()
    {
      return name_;
    }

    const ::std::string& BackupOrResizeInProgress::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BackupOrResizeInProgress::
    _name () const
    {
      return name_;
    }

    const ::std::string& BackupOrResizeInProgress::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BackupOrResizeInProgress::
    name_ ("backupOrResizeInProgress");

    const ::std::string BackupOrResizeInProgress::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    BackupOrResizeInProgress::
    ~BackupOrResizeInProgress ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BackupOrResizeInProgress, char, ::xml_schema::Type >
    _xsd_BackupOrResizeInProgress_parser_init (BackupOrResizeInProgress::name (), BackupOrResizeInProgress::namespace_ ());

    // ResizeNotAllowed
    // 

    const ::xml_schema::Type* ResizeNotAllowed::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* ResizeNotAllowed::
    _value ()
    {
      return &this->value_.get ();
    }

    ResizeNotAllowed::
    ResizeNotAllowed (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    ResizeNotAllowed::
    ResizeNotAllowed (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    ResizeNotAllowed::
    ResizeNotAllowed (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ResizeNotAllowed::
    ResizeNotAllowed (const ResizeNotAllowed& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    ResizeNotAllowed* ResizeNotAllowed::
    _clone (::xml_schema::Flags f) const
    {
      return new class ResizeNotAllowed (*this, f);
    }

    const ::std::string& ResizeNotAllowed::
    name ()
    {
      return name_;
    }

    const ::std::string& ResizeNotAllowed::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ResizeNotAllowed::
    _name () const
    {
      return name_;
    }

    const ::std::string& ResizeNotAllowed::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ResizeNotAllowed::
    name_ ("resizeNotAllowed");

    const ::std::string ResizeNotAllowed::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    ResizeNotAllowed::
    ~ResizeNotAllowed ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ResizeNotAllowed, char, ::xml_schema::Type >
    _xsd_ResizeNotAllowed_parser_init (ResizeNotAllowed::name (), ResizeNotAllowed::namespace_ ());

    // ServiceUnavailable
    // 

    const ::xml_schema::Type* ServiceUnavailable::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* ServiceUnavailable::
    _value ()
    {
      return &this->value_.get ();
    }

    ServiceUnavailable::
    ServiceUnavailable (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    ServiceUnavailable::
    ServiceUnavailable (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    ServiceUnavailable::
    ServiceUnavailable (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    ServiceUnavailable::
    ServiceUnavailable (const ServiceUnavailable& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    ServiceUnavailable* ServiceUnavailable::
    _clone (::xml_schema::Flags f) const
    {
      return new class ServiceUnavailable (*this, f);
    }

    const ::std::string& ServiceUnavailable::
    name ()
    {
      return name_;
    }

    const ::std::string& ServiceUnavailable::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& ServiceUnavailable::
    _name () const
    {
      return name_;
    }

    const ::std::string& ServiceUnavailable::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string ServiceUnavailable::
    name_ ("serviceUnavailable");

    const ::std::string ServiceUnavailable::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    ServiceUnavailable::
    ~ServiceUnavailable ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< ServiceUnavailable, char, ::xml_schema::Type >
    _xsd_ServiceUnavailable_parser_init (ServiceUnavailable::name (), ServiceUnavailable::namespace_ ());

    // Unauthorized
    // 

    const ::xml_schema::Type* Unauthorized::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* Unauthorized::
    _value ()
    {
      return &this->value_.get ();
    }

    Unauthorized::
    Unauthorized (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    Unauthorized::
    Unauthorized (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    Unauthorized::
    Unauthorized (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    Unauthorized::
    Unauthorized (const Unauthorized& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    Unauthorized* Unauthorized::
    _clone (::xml_schema::Flags f) const
    {
      return new class Unauthorized (*this, f);
    }

    const ::std::string& Unauthorized::
    name ()
    {
      return name_;
    }

    const ::std::string& Unauthorized::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& Unauthorized::
    _name () const
    {
      return name_;
    }

    const ::std::string& Unauthorized::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string Unauthorized::
    name_ ("unauthorized");

    const ::std::string Unauthorized::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    Unauthorized::
    ~Unauthorized ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< Unauthorized, char, ::xml_schema::Type >
    _xsd_Unauthorized_parser_init (Unauthorized::name (), Unauthorized::namespace_ ());

    // OverLimit
    // 

    const ::xml_schema::Type* OverLimit::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* OverLimit::
    _value ()
    {
      return &this->value_.get ();
    }

    OverLimit::
    OverLimit (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    OverLimit::
    OverLimit (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    OverLimit::
    OverLimit (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    OverLimit::
    OverLimit (const OverLimit& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    OverLimit* OverLimit::
    _clone (::xml_schema::Flags f) const
    {
      return new class OverLimit (*this, f);
    }

    const ::std::string& OverLimit::
    name ()
    {
      return name_;
    }

    const ::std::string& OverLimit::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& OverLimit::
    _name () const
    {
      return name_;
    }

    const ::std::string& OverLimit::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string OverLimit::
    name_ ("overLimit");

    const ::std::string OverLimit::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    OverLimit::
    ~OverLimit ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< OverLimit, char, ::xml_schema::Type >
    _xsd_OverLimit_parser_init (OverLimit::name (), OverLimit::namespace_ ());

    // BadRequest
    // 

    const ::xml_schema::Type* BadRequest::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* BadRequest::
    _value ()
    {
      return &this->value_.get ();
    }

    BadRequest::
    BadRequest (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    BadRequest::
    BadRequest (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    BadRequest::
    BadRequest (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BadRequest::
    BadRequest (const BadRequest& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    BadRequest* BadRequest::
    _clone (::xml_schema::Flags f) const
    {
      return new class BadRequest (*this, f);
    }

    const ::std::string& BadRequest::
    name ()
    {
      return name_;
    }

    const ::std::string& BadRequest::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BadRequest::
    _name () const
    {
      return name_;
    }

    const ::std::string& BadRequest::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BadRequest::
    name_ ("badRequest");

    const ::std::string BadRequest::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    BadRequest::
    ~BadRequest ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BadRequest, char, ::xml_schema::Type >
    _xsd_BadRequest_parser_init (BadRequest::name (), BadRequest::namespace_ ());

    // BadMediaType
    // 

    const ::xml_schema::Type* BadMediaType::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* BadMediaType::
    _value ()
    {
      return &this->value_.get ();
    }

    BadMediaType::
    BadMediaType (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    BadMediaType::
    BadMediaType (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    BadMediaType::
    BadMediaType (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BadMediaType::
    BadMediaType (const BadMediaType& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    BadMediaType* BadMediaType::
    _clone (::xml_schema::Flags f) const
    {
      return new class BadMediaType (*this, f);
    }

    const ::std::string& BadMediaType::
    name ()
    {
      return name_;
    }

    const ::std::string& BadMediaType::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BadMediaType::
    _name () const
    {
      return name_;
    }

    const ::std::string& BadMediaType::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BadMediaType::
    name_ ("badMediaType");

    const ::std::string BadMediaType::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    BadMediaType::
    ~BadMediaType ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BadMediaType, char, ::xml_schema::Type >
    _xsd_BadMediaType_parser_init (BadMediaType::name (), BadMediaType::namespace_ ());

    // BadMethod
    // 

    const ::xml_schema::Type* BadMethod::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* BadMethod::
    _value ()
    {
      return &this->value_.get ();
    }

    BadMethod::
    BadMethod (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    BadMethod::
    BadMethod (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    BadMethod::
    BadMethod (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    BadMethod::
    BadMethod (const BadMethod& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    BadMethod* BadMethod::
    _clone (::xml_schema::Flags f) const
    {
      return new class BadMethod (*this, f);
    }

    const ::std::string& BadMethod::
    name ()
    {
      return name_;
    }

    const ::std::string& BadMethod::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& BadMethod::
    _name () const
    {
      return name_;
    }

    const ::std::string& BadMethod::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string BadMethod::
    name_ ("badMethod");

    const ::std::string BadMethod::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    BadMethod::
    ~BadMethod ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< BadMethod, char, ::xml_schema::Type >
    _xsd_BadMethod_parser_init (BadMethod::name (), BadMethod::namespace_ ());

    // NotImplemented
    // 

    const ::xml_schema::Type* NotImplemented::
    _value () const
    {
      return &this->value_.get ();
    }

    ::xml_schema::Type* NotImplemented::
    _value ()
    {
      return &this->value_.get ();
    }

    NotImplemented::
    NotImplemented (const ValueType& x)
    : value_ (x, 0, 0)
    {
    }

    NotImplemented::
    NotImplemented (::std::auto_ptr< ValueType > p)
    : value_ (p, 0, 0)
    {
    }

    NotImplemented::
    NotImplemented (const ::xercesc::DOMElement& e, ::xml_schema::Flags f)
    : value_ (f, 0)
    {
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == name_ && n.namespace_ () == namespace__)
        this->value_.set (ValueTraits::create (e, f, 0));
      else
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (), n.namespace_ (),
          name_, namespace__);
    }

    NotImplemented::
    NotImplemented (const NotImplemented& x, ::xml_schema::Flags f)
    : ::xml_schema::ElementType (),
      value_ (x.value_, f, 0)
    {
    }

    NotImplemented* NotImplemented::
    _clone (::xml_schema::Flags f) const
    {
      return new class NotImplemented (*this, f);
    }

    const ::std::string& NotImplemented::
    name ()
    {
      return name_;
    }

    const ::std::string& NotImplemented::
    namespace_ ()
    {
      return namespace__;
    }

    const ::std::string& NotImplemented::
    _name () const
    {
      return name_;
    }

    const ::std::string& NotImplemented::
    _namespace () const
    {
      return namespace__;
    }

    const ::std::string NotImplemented::
    name_ ("notImplemented");

    const ::std::string NotImplemented::
    namespace__ ("http://docs.rackspacecloud.com/servers/api/v1.0");

    NotImplemented::
    ~NotImplemented ()
    {
    }

    static 
    const ::xsd::cxx::tree::parser_init< NotImplemented, char, ::xml_schema::Type >
    _xsd_NotImplemented_parser_init (NotImplemented::name (), NotImplemented::namespace_ ());

    // CloudServersAPIFault
    //

    CloudServersAPIFault::
    CloudServersAPIFault (const MessageType& message,
                          const CodeType& code)
    : ::xml_schema::Type (),
      message_ (message, ::xml_schema::Flags (), this),
      details_ (::xml_schema::Flags (), this),
      code_ (code, ::xml_schema::Flags (), this)
    {
    }

    CloudServersAPIFault::
    CloudServersAPIFault (::std::auto_ptr< MessageType >& message,
                          const CodeType& code)
    : ::xml_schema::Type (),
      message_ (message, ::xml_schema::Flags (), this),
      details_ (::xml_schema::Flags (), this),
      code_ (code, ::xml_schema::Flags (), this)
    {
    }

    CloudServersAPIFault::
    CloudServersAPIFault (const CloudServersAPIFault& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      message_ (x.message_, f, this),
      details_ (x.details_, f, this),
      code_ (x.code_, f, this)
    {
    }

    CloudServersAPIFault::
    CloudServersAPIFault (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      message_ (f, this),
      details_ (f, this),
      code_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CloudServersAPIFault::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // message
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "message",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< MessageType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!message_.present ())
            {
              ::std::auto_ptr< MessageType > r (
                dynamic_cast< MessageType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->message_.set (r);
              continue;
            }
          }
        }

        // details
        //
        {
          ::xsd::cxx::tree::type_factory_map< char >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              "details",
              "http://docs.rackspacecloud.com/servers/api/v1.0",
              &::xsd::cxx::tree::factory_impl< DetailsType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->details_)
            {
              ::std::auto_ptr< DetailsType > r (
                dynamic_cast< DetailsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->details_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!message_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "message",
          "http://docs.rackspacecloud.com/servers/api/v1.0");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "code" && n.namespace_ ().empty ())
        {
          this->code_.set (CodeTraits::create (i, f, this));
          continue;
        }
      }

      if (!code_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "code",
          "");
      }
    }

    CloudServersAPIFault* CloudServersAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CloudServersAPIFault (*this, f, c);
    }

    CloudServersAPIFault::
    ~CloudServersAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CloudServersAPIFault >
    _xsd_CloudServersAPIFault_type_factory_init (
      "CloudServersAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ItemNotFoundAPIFault
    //

    ItemNotFoundAPIFault::
    ItemNotFoundAPIFault (const MessageType& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ItemNotFoundAPIFault::
    ItemNotFoundAPIFault (::std::auto_ptr< MessageType >& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ItemNotFoundAPIFault::
    ItemNotFoundAPIFault (const ItemNotFoundAPIFault& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    ItemNotFoundAPIFault::
    ItemNotFoundAPIFault (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    ItemNotFoundAPIFault* ItemNotFoundAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ItemNotFoundAPIFault (*this, f, c);
    }

    ItemNotFoundAPIFault::
    ~ItemNotFoundAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ItemNotFoundAPIFault >
    _xsd_ItemNotFoundAPIFault_type_factory_init (
      "ItemNotFoundAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // BuildInProgressAPIFault
    //

    BuildInProgressAPIFault::
    BuildInProgressAPIFault (const MessageType& message,
                             const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BuildInProgressAPIFault::
    BuildInProgressAPIFault (::std::auto_ptr< MessageType >& message,
                             const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BuildInProgressAPIFault::
    BuildInProgressAPIFault (const BuildInProgressAPIFault& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    BuildInProgressAPIFault::
    BuildInProgressAPIFault (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    BuildInProgressAPIFault* BuildInProgressAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BuildInProgressAPIFault (*this, f, c);
    }

    BuildInProgressAPIFault::
    ~BuildInProgressAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BuildInProgressAPIFault >
    _xsd_BuildInProgressAPIFault_type_factory_init (
      "BuildInProgressAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ServerCapacityUnavailableAPIFault
    //

    ServerCapacityUnavailableAPIFault::
    ServerCapacityUnavailableAPIFault (const MessageType& message,
                                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ServerCapacityUnavailableAPIFault::
    ServerCapacityUnavailableAPIFault (::std::auto_ptr< MessageType >& message,
                                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ServerCapacityUnavailableAPIFault::
    ServerCapacityUnavailableAPIFault (const ServerCapacityUnavailableAPIFault& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    ServerCapacityUnavailableAPIFault::
    ServerCapacityUnavailableAPIFault (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    ServerCapacityUnavailableAPIFault* ServerCapacityUnavailableAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ServerCapacityUnavailableAPIFault (*this, f, c);
    }

    ServerCapacityUnavailableAPIFault::
    ~ServerCapacityUnavailableAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ServerCapacityUnavailableAPIFault >
    _xsd_ServerCapacityUnavailableAPIFault_type_factory_init (
      "ServerCapacityUnavailableAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // BackupOrResizeInProgressAPIFault
    //

    BackupOrResizeInProgressAPIFault::
    BackupOrResizeInProgressAPIFault (const MessageType& message,
                                      const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BackupOrResizeInProgressAPIFault::
    BackupOrResizeInProgressAPIFault (::std::auto_ptr< MessageType >& message,
                                      const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BackupOrResizeInProgressAPIFault::
    BackupOrResizeInProgressAPIFault (const BackupOrResizeInProgressAPIFault& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    BackupOrResizeInProgressAPIFault::
    BackupOrResizeInProgressAPIFault (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    BackupOrResizeInProgressAPIFault* BackupOrResizeInProgressAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BackupOrResizeInProgressAPIFault (*this, f, c);
    }

    BackupOrResizeInProgressAPIFault::
    ~BackupOrResizeInProgressAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BackupOrResizeInProgressAPIFault >
    _xsd_BackupOrResizeInProgressAPIFault_type_factory_init (
      "BackupOrResizeInProgressAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ResizeNotAllowedAPIFault
    //

    ResizeNotAllowedAPIFault::
    ResizeNotAllowedAPIFault (const MessageType& message,
                              const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ResizeNotAllowedAPIFault::
    ResizeNotAllowedAPIFault (::std::auto_ptr< MessageType >& message,
                              const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ResizeNotAllowedAPIFault::
    ResizeNotAllowedAPIFault (const ResizeNotAllowedAPIFault& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    ResizeNotAllowedAPIFault::
    ResizeNotAllowedAPIFault (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    ResizeNotAllowedAPIFault* ResizeNotAllowedAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResizeNotAllowedAPIFault (*this, f, c);
    }

    ResizeNotAllowedAPIFault::
    ~ResizeNotAllowedAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResizeNotAllowedAPIFault >
    _xsd_ResizeNotAllowedAPIFault_type_factory_init (
      "ResizeNotAllowedAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // ServiceUnavailableAPIFault
    //

    ServiceUnavailableAPIFault::
    ServiceUnavailableAPIFault (const MessageType& message,
                                const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ServiceUnavailableAPIFault::
    ServiceUnavailableAPIFault (::std::auto_ptr< MessageType >& message,
                                const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    ServiceUnavailableAPIFault::
    ServiceUnavailableAPIFault (const ServiceUnavailableAPIFault& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    ServiceUnavailableAPIFault::
    ServiceUnavailableAPIFault (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    ServiceUnavailableAPIFault* ServiceUnavailableAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ServiceUnavailableAPIFault (*this, f, c);
    }

    ServiceUnavailableAPIFault::
    ~ServiceUnavailableAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ServiceUnavailableAPIFault >
    _xsd_ServiceUnavailableAPIFault_type_factory_init (
      "ServiceUnavailableAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // UnauthorizedAPIFault
    //

    UnauthorizedAPIFault::
    UnauthorizedAPIFault (const MessageType& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    UnauthorizedAPIFault::
    UnauthorizedAPIFault (::std::auto_ptr< MessageType >& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    UnauthorizedAPIFault::
    UnauthorizedAPIFault (const UnauthorizedAPIFault& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    UnauthorizedAPIFault::
    UnauthorizedAPIFault (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    UnauthorizedAPIFault* UnauthorizedAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UnauthorizedAPIFault (*this, f, c);
    }

    UnauthorizedAPIFault::
    ~UnauthorizedAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnauthorizedAPIFault >
    _xsd_UnauthorizedAPIFault_type_factory_init (
      "UnauthorizedAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // OverLimitAPIFault
    //

    OverLimitAPIFault::
    OverLimitAPIFault (const MessageType& message,
                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code),
      retryAfter_ (::xml_schema::Flags (), this)
    {
    }

    OverLimitAPIFault::
    OverLimitAPIFault (::std::auto_ptr< MessageType >& message,
                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code),
      retryAfter_ (::xml_schema::Flags (), this)
    {
    }

    OverLimitAPIFault::
    OverLimitAPIFault (const OverLimitAPIFault& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c),
      retryAfter_ (x.retryAfter_, f, this)
    {
    }

    OverLimitAPIFault::
    OverLimitAPIFault (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f | ::xml_schema::Flags::base, c),
      retryAfter_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OverLimitAPIFault::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::openstack::xml::CloudServersAPIFault::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "retryAfter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< RetryAfterType > r (
            RetryAfterTraits::create (i, f, this));

          this->retryAfter_.set (r);
          continue;
        }
      }
    }

    OverLimitAPIFault* OverLimitAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class OverLimitAPIFault (*this, f, c);
    }

    OverLimitAPIFault::
    ~OverLimitAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OverLimitAPIFault >
    _xsd_OverLimitAPIFault_type_factory_init (
      "OverLimitAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // BadRequestAPIFault
    //

    BadRequestAPIFault::
    BadRequestAPIFault (const MessageType& message,
                        const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadRequestAPIFault::
    BadRequestAPIFault (::std::auto_ptr< MessageType >& message,
                        const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadRequestAPIFault::
    BadRequestAPIFault (const BadRequestAPIFault& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    BadRequestAPIFault::
    BadRequestAPIFault (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    BadRequestAPIFault* BadRequestAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BadRequestAPIFault (*this, f, c);
    }

    BadRequestAPIFault::
    ~BadRequestAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BadRequestAPIFault >
    _xsd_BadRequestAPIFault_type_factory_init (
      "BadRequestAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // BadMediaTypeAPIFault
    //

    BadMediaTypeAPIFault::
    BadMediaTypeAPIFault (const MessageType& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadMediaTypeAPIFault::
    BadMediaTypeAPIFault (::std::auto_ptr< MessageType >& message,
                          const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadMediaTypeAPIFault::
    BadMediaTypeAPIFault (const BadMediaTypeAPIFault& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    BadMediaTypeAPIFault::
    BadMediaTypeAPIFault (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    BadMediaTypeAPIFault* BadMediaTypeAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BadMediaTypeAPIFault (*this, f, c);
    }

    BadMediaTypeAPIFault::
    ~BadMediaTypeAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BadMediaTypeAPIFault >
    _xsd_BadMediaTypeAPIFault_type_factory_init (
      "BadMediaTypeAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // BadMethodAPIFault
    //

    BadMethodAPIFault::
    BadMethodAPIFault (const MessageType& message,
                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadMethodAPIFault::
    BadMethodAPIFault (::std::auto_ptr< MessageType >& message,
                       const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    BadMethodAPIFault::
    BadMethodAPIFault (const BadMethodAPIFault& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    BadMethodAPIFault::
    BadMethodAPIFault (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    BadMethodAPIFault* BadMethodAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BadMethodAPIFault (*this, f, c);
    }

    BadMethodAPIFault::
    ~BadMethodAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BadMethodAPIFault >
    _xsd_BadMethodAPIFault_type_factory_init (
      "BadMethodAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");

    // NotImplementedAPIFault
    //

    NotImplementedAPIFault::
    NotImplementedAPIFault (const MessageType& message,
                            const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    NotImplementedAPIFault::
    NotImplementedAPIFault (::std::auto_ptr< MessageType >& message,
                            const CodeType& code)
    : ::openstack::xml::CloudServersAPIFault (message,
                                              code)
    {
    }

    NotImplementedAPIFault::
    NotImplementedAPIFault (const NotImplementedAPIFault& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (x, f, c)
    {
    }

    NotImplementedAPIFault::
    NotImplementedAPIFault (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::openstack::xml::CloudServersAPIFault (e, f, c)
    {
    }

    NotImplementedAPIFault* NotImplementedAPIFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NotImplementedAPIFault (*this, f, c);
    }

    NotImplementedAPIFault::
    ~NotImplementedAPIFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NotImplementedAPIFault >
    _xsd_NotImplementedAPIFault_type_factory_init (
      "NotImplementedAPIFault",
      "http://docs.rackspacecloud.com/servers/api/v1.0");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

